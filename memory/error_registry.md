# Error Registry
| Context | The Error | The Fix | Prevention Rule |
| :--- | :--- | :--- | :--- |
| **Garmin Integration** | `TS2304: Cannot find name 'GarminConnect'` | Created `src/types/declarations.d.ts` | **Dependency Typings**: Always check for `@types/package` or create a declaration file immediately. |
| **Garmin Adapter** | `TS2322: Type 'string' is not assignable to type 'number'` (ISessionStream) | Updated adapter to strict interface match | **Strict Interface Adherence**: Verify adapter outputs against interfaces before building. |
| **Session Types** | `TS2322: Property 'heartRate' is missing` | Made `heartRate` optional (`?`) in `ISessionDataPoint` | **Real World Data**: Sensor data is never perfect; optional fields are necessary. |
| **HighRev Filter** | `TS18048: 'p.heartRate' is possibly 'undefined'` | Added null check `if (!p.heartRate) continue` | **Strict Null Checks**: Always guard optional properties in calculation logic. |
| **Python Integration** | `CommandNotFoundException: uv` | Use `pip install` or ensure `uv` is in PATH. | **Environment Checks**: Verify CLI tools exist before running shell commands. |
| **Unit Testing** | `Cadence Lock Test Failed` (False Negative) | Fixed test data generation to ensure shared noise source. | **Test Fidelity**: When testing correlation algorithms, synthetic data must actually be correlated (use shared variables). |
| **Type Safety** | `any` types in `garminAdapter.ts` and `actions.ts` | Created `src/types/garmin.ts` with proper interfaces, replaced `error: any` with `error: unknown` | **Strict Typing**: Never use `any`; create proper TypeScript interfaces for external APIs. Use `unknown` for error handling. |
| **Mock Data UUID** | `invalid input syntax for type uuid: 'phoenix_high_rev_01'` | Added UUID validation, auto-reload from Supabase if mock ID detected, prevent mock profile persistence | **UUID Validation**: Always validate UUIDs before database operations. Never persist mock IDs to Supabase. |
| **File Complexity** | Files exceeding 100-line MAKER limit (251, 245, 234, 217, 184 lines) | Decomposed into atomic modules: `logic/` subdirectories with single-responsibility functions | **MAKER Decomposition**: Files must not exceed 100 lines. Extract logic into `logic/` subdirectories following single responsibility principle. |
| **Component Decomposition** | Files exceeding 100-line MAKER limit (128, 132, 173 lines) | Decomposed `CertaintyScore.tsx`, `DecisionLog.tsx`, `PlanDailyMissionCard.tsx` into sub-components and utility modules | **MAKER Decomposition**: Component files exceeding 100 lines must be split into smaller sub-components and utility functions in `logic/` directories. |
| **React Component Creation** | `Cannot create components during render` error when returning JSX from utility functions | Changed utility functions to return `ReactElement` directly instead of component constructors | **React Best Practices**: Utility functions that return JSX should return `ReactElement`, not component constructors. Use `renderModalityIcon()` pattern instead of `getModalityIcon()`. |
| **Garmin Sync Rate Limiting** | `HTTP 429 Too Many Requests` from Garmin API (Cloudflare protection) | Implemented fragmented batch sync (5 activities per batch), exponential backoff retry logic, 2-5 second delays between requests, and date-range chunking (7-day patches) | **Rate Limit Handling**: External APIs with rate limits require: (1) Small batch sizes, (2) Delays between requests, (3) Retry with exponential backoff, (4) Chunking large date ranges into smaller sequential requests. Always check for 429 errors and stop gracefully. |
| **Garmin Sync Date Range** | Initial sync tried to fetch all activities at once, causing rate limits | Changed to date-range based sync with 7-day chunking. User selects start/end dates, system splits into sequential patches | **Date Range Chunking**: Large date ranges (>7 days) must be split into sequential chunks to avoid rate limits. Extract chunking logic to separate utility function for testability. |
| **Empty Date Range Query** | `invalid input syntax for type date: ""` error when dateRange.start is empty string | Added validation in `sessionLoader.ts` to check for empty/invalid dates and use default values (30 days ago to today) if empty. Validates date format (YYYY-MM-DD) before querying. | **Date Validation**: Always validate date inputs before using in database queries. Check for empty strings, validate format, and provide sensible defaults. Never pass empty strings to date filters in Supabase queries. |
| **Garmin API Usage Pattern** | Using npm `garmin-connect` package incorrectly - no token persistence, inefficient pagination | Switched to MCP server's Python client via subprocess. Uses `get_activities_by_date()` for efficient queries and OAuth token persistence (`~/.garminconnect/`). Falls back to npm client if Python unavailable. | **External API Integration**: When available, use official/supported clients with token persistence. Avoid repeated authentication - it triggers rate limits. Use date-range queries instead of pagination when possible. Always provide fallback for missing dependencies. |
| **Prototype Regeneration** | Page files exceed 100-line MAKER limit (413, 270, 238, 193, 180, 165, 143 lines) | Files intentionally match prototype structure (1133-line single file). Decomposition deferred to optimization phase. Created type adapters (`prototype.ts`) to bridge prototype and database types. | **Prototype Fidelity vs MAKER Compliance**: When regenerating from prototype, visual/UX parity takes precedence. Document oversized files for later decomposition. Use type adapters to isolate prototype-specific structures from database types. Decomposition should be a follow-up optimization task, not blocking for initial implementation. |
| **React useEffect Infinite Loop** | Settings page constantly polling Supabase endpoint - `useEffect` dependency array includes reactive store value that gets updated by the effect itself | Removed reactive `profile` from dependency array. Use `usePhenotypeStore.getState().profile` inside effect to access current value without creating dependency. Effect runs once on mount with empty dependency array. | **Zustand Store in useEffect**: Never include reactive store values in `useEffect` dependency arrays if the effect updates those values. Use `store.getState()` to access current value inside effect without creating dependency. For one-time loads, use empty dependency array `[]`. If you need to react to store changes, use `useEffect` with store subscription or Zustand's built-in selector hooks. |
| **Type Adapter Pattern** | Prototype data structures don't match database types (SessionDetail vs SessionWithVotes) | Created `src/types/prototype.ts` with adapter functions (`sessionWithVotesToPrototype`, `workoutToPrototypeSession`) to transform between formats. Prototype types isolated from database schema. | **Data Transformation Layer**: When integrating prototype UI with real data, create explicit adapter functions. Keep prototype types separate from database types. Adapters handle all transformations (date formatting, enum mapping, metadata extraction). This allows prototype UI to remain unchanged while database schema evolves. |
| **Responsive Layout Pattern** | Mobile-first design requires different navigation (bottom nav vs sidebar) | Implemented conditional rendering in `layout.tsx` using Tailwind `md:` breakpoints. Mobile shows `TopNav` + `BottomNav`, desktop shows `Sidebar`. Main content uses `max-w-md mx-auto md:max-w-none` for mobile centering. | **Responsive Navigation**: Use conditional rendering based on screen size, not CSS-only hiding. Mobile-first means bottom navigation for thumb accessibility. Desktop uses sidebar for better screen real estate. Container width constraints (`max-w-md`) only apply on mobile to prevent text from stretching too wide. |
| **Probability Calculation Bug** | Macro-Engine probability showing 9580% (impossible value) | Removed double multiplication by 100, added 85% cap using `Math.min(85, probability)` in both Dashboard and ValuationEngine. Constant `MAX_PROBABILITY = 85` enforces "Zero-Error" philosophy - never promise certainty in chaotic biological systems. | **Probability Capping**: Always cap success probabilities at realistic maximums (85% for marathon). Never display >90% as it indicates over-fitting or ignoring Black Swan risks. Apply cap at both calculation and display layers. |
| **Decoupling Calculation Data Dependency** | Client-side EF calculation requires first/second half metrics that may not exist in metadata | Implemented fallback chain: (1) Use pre-calculated `decoupling` from metadata if available, (2) Calculate from `firstHalfPace/HR` and `secondHalfPace/HR` if available, (3) Fallback to estimated 2.5% if no data. | **Client-Side Calculation Fallbacks**: When implementing client-side calculations from metadata, always provide multiple fallback strategies. Document data dependencies clearly. Recommendation: Calculate and store first/second half metrics during session processing for accurate EF calculation. |
| **Integrity Ratio Unit Mismatch** | Ratio calculation (Tonnage/Volume) produces meaningless values (e.g., 10,000kg vs 100km = 100:1) | Normalize units before calculating ratio: `(Tonnage/1000) / (Volume/10)`. This prevents unit mismatch and makes ratio meaningful (e.g., 10kg tonnage / 10km volume = 0.1 ratio). | **Unit Normalization**: Always normalize units before calculating ratios between different measurement types. Document normalization factors clearly. Consider creating utility functions for common unit conversions (e.g., `normalizeTonnage()`, `normalizeVolume()`). |
| **Sync Button UX Failure** | Sync button disappears or becomes disabled after sync, requiring manual refresh | Button always visible with status indicators: "Syncing...", "Up to Date" (green), "Wait Xm" (cooldown), "Sync Garmin" (idle). Auto-sync check on app foreground (every 30s + on focus). Visual feedback shows last sync time in tooltip. | **Persistent Status Indicators**: Sync buttons should remain visible and show current status. Implement auto-sync checks on app foregrounding. Use visual indicators (colors, icons) to communicate state. Button is fallback, not primary interaction - status should be automatic. |
| **Server Action Complexity** | `actions.ts` exceeds 100-line MAKER limit (575 lines) after refactoring to DB-backed logic | File orchestrates complex multi-step analysis flow: auth check, profile load, snapshot cache, audit gating, session processing, analysis, decision generation, persistence. Decomposition deferred - file serves as clear orchestration layer. | **Orchestration Files**: Server action files that coordinate multiple modules may exceed 100 lines if they serve as clear orchestration layers. Consider extracting helper functions to `logic/` subdirectories if file grows beyond 600 lines. Keep orchestration logic at top level for readability. |
| **Zustand in Server Actions** | Server actions using `usePhenotypeStore.getState()` and `useMonitorStore.getState()` - zustand stores don't work in server context | Refactored to fetch all data from Supabase using `createServerClient()`. Removed all zustand usage from server actions. Auth enforced by getting userId from `supabase.auth.getSession()` and using it in all queries. | **Server Action Data Access**: Never use client-side stores (zustand, context) in server actions. Always fetch data from database using server-side Supabase client. Enforce auth by getting userId from session and verifying all queries use authenticated user. Use snapshot caching to avoid repeated heavy computation. |
| **Calendar Date Range Logic Bug** | Tactical Map calendar showing `isPast: i < 0` always false because loop starts at `i = 0` and only goes forward. Past sessions never displayed. Date range query loaded past 7 days but calendar only showed next 7 days. | Fixed calendar generation to show 3 days past → today → 3 days future (7 days total). Corrected `isPast` calculation. Updated date range query to match calendar range (3 days past to 3 days future). Added proper session status detection. | **Calendar Date Logic**: When generating calendar days, ensure date range matches query range. Use negative loop indices for past days (e.g., `for (let i = -3; i <= 3; i++)`). Always normalize dates to start of day (`setHours(0, 0, 0, 0)`) before comparing. Query date range must cover all displayed calendar days. |
| **Garmin Duration Extraction Null Checking** | Python `extract_duration()` function not properly checking for `None` before type checking, causing some valid durations to be missed. Garmin API returns `duration` as float number, not object, but function was checking dict first. | Enhanced function with explicit `is not None` checks before type validation. Improved priority order: check float number first (most common case), then dict (fallback). Added comprehensive logging for debugging. TypeScript side also enhanced with better fallback chain and validation to skip invalid durations. | **Null Safety in Python**: Always use `is not None` before type checking in Python. Check most common data format first (float numbers for Garmin duration), then handle edge cases (dict format). Use explicit type guards: `if value is not None and isinstance(value, (int, float)) and value > 0`. Add logging at each extraction step for debugging. |
| **Date Range Query Mismatch** | Calendar displays date range that doesn't match database query range, causing missing data. Query loads past 7 days but calendar shows next 7 days (including today). | Aligned query range with calendar display range. Query now loads 3 days past to 3 days future to match calendar. Added date normalization (`setHours(0, 0, 0, 0)`) for accurate comparisons. | **Date Range Alignment**: Always ensure database query date range matches UI display range. When showing calendar with past/future days, query must cover all displayed dates. Normalize dates to start of day before querying/comparing. Use inclusive ranges (`gte`/`lte`) for date queries. |
