# Error Registry
| Context | The Error | The Fix | Prevention Rule |
| :--- | :--- | :--- | :--- |
| **Garmin Integration** | `TS2304: Cannot find name 'GarminConnect'` | Created `src/types/declarations.d.ts` | **Dependency Typings**: Always check for `@types/package` or create a declaration file immediately. |
| **Garmin Adapter** | `TS2322: Type 'string' is not assignable to type 'number'` (ISessionStream) | Updated adapter to strict interface match | **Strict Interface Adherence**: Verify adapter outputs against interfaces before building. |
| **Session Types** | `TS2322: Property 'heartRate' is missing` | Made `heartRate` optional (`?`) in `ISessionDataPoint` | **Real World Data**: Sensor data is never perfect; optional fields are necessary. |
| **HighRev Filter** | `TS18048: 'p.heartRate' is possibly 'undefined'` | Added null check `if (!p.heartRate) continue` | **Strict Null Checks**: Always guard optional properties in calculation logic. |
| **Python Integration** | `CommandNotFoundException: uv` | Use `pip install` or ensure `uv` is in PATH. | **Environment Checks**: Verify CLI tools exist before running shell commands. |
| **Unit Testing** | `Cadence Lock Test Failed` (False Negative) | Fixed test data generation to ensure shared noise source. | **Test Fidelity**: When testing correlation algorithms, synthetic data must actually be correlated (use shared variables). |
| **Type Safety** | `any` types in `garminAdapter.ts` and `actions.ts` | Created `src/types/garmin.ts` with proper interfaces, replaced `error: any` with `error: unknown` | **Strict Typing**: Never use `any`; create proper TypeScript interfaces for external APIs. Use `unknown` for error handling. |
| **Mock Data UUID** | `invalid input syntax for type uuid: 'phoenix_high_rev_01'` | Added UUID validation, auto-reload from Supabase if mock ID detected, prevent mock profile persistence | **UUID Validation**: Always validate UUIDs before database operations. Never persist mock IDs to Supabase. |
| **File Complexity** | Files exceeding 100-line MAKER limit (251, 245, 234, 217, 184 lines) | Decomposed into atomic modules: `logic/` subdirectories with single-responsibility functions | **MAKER Decomposition**: Files must not exceed 100 lines. Extract logic into `logic/` subdirectories following single responsibility principle. |
| **Component Decomposition** | Files exceeding 100-line MAKER limit (128, 132, 173 lines) | Decomposed `CertaintyScore.tsx`, `DecisionLog.tsx`, `PlanDailyMissionCard.tsx` into sub-components and utility modules | **MAKER Decomposition**: Component files exceeding 100 lines must be split into smaller sub-components and utility functions in `logic/` directories. |
| **React Component Creation** | `Cannot create components during render` error when returning JSX from utility functions | Changed utility functions to return `ReactElement` directly instead of component constructors | **React Best Practices**: Utility functions that return JSX should return `ReactElement`, not component constructors. Use `renderModalityIcon()` pattern instead of `getModalityIcon()`. |
| **Garmin Sync Rate Limiting** | `HTTP 429 Too Many Requests` from Garmin API (Cloudflare protection) | Implemented fragmented batch sync (5 activities per batch), exponential backoff retry logic, 2-5 second delays between requests, and date-range chunking (7-day patches) | **Rate Limit Handling**: External APIs with rate limits require: (1) Small batch sizes, (2) Delays between requests, (3) Retry with exponential backoff, (4) Chunking large date ranges into smaller sequential requests. Always check for 429 errors and stop gracefully. |
| **Garmin Sync Date Range** | Initial sync tried to fetch all activities at once, causing rate limits | Changed to date-range based sync with 7-day chunking. User selects start/end dates, system splits into sequential patches | **Date Range Chunking**: Large date ranges (>7 days) must be split into sequential chunks to avoid rate limits. Extract chunking logic to separate utility function for testability. |
| **Empty Date Range Query** | `invalid input syntax for type date: ""` error when dateRange.start is empty string | Added validation in `sessionLoader.ts` to check for empty/invalid dates and use default values (30 days ago to today) if empty. Validates date format (YYYY-MM-DD) before querying. | **Date Validation**: Always validate date inputs before using in database queries. Check for empty strings, validate format, and provide sensible defaults. Never pass empty strings to date filters in Supabase queries. |
| **Garmin API Usage Pattern** | Using npm `garmin-connect` package incorrectly - no token persistence, inefficient pagination | Switched to MCP server's Python client via subprocess. Uses `get_activities_by_date()` for efficient queries and OAuth token persistence (`~/.garminconnect/`). Falls back to npm client if Python unavailable. | **External API Integration**: When available, use official/supported clients with token persistence. Avoid repeated authentication - it triggers rate limits. Use date-range queries instead of pagination when possible. Always provide fallback for missing dependencies. |
| **Prototype Regeneration** | Page files exceed 100-line MAKER limit (413, 270, 238, 193, 180, 165, 143 lines) | Files intentionally match prototype structure (1133-line single file). Decomposition deferred to optimization phase. Created type adapters (`prototype.ts`) to bridge prototype and database types. | **Prototype Fidelity vs MAKER Compliance**: When regenerating from prototype, visual/UX parity takes precedence. Document oversized files for later decomposition. Use type adapters to isolate prototype-specific structures from database types. Decomposition should be a follow-up optimization task, not blocking for initial implementation. |
| **React useEffect Infinite Loop** | Settings page constantly polling Supabase endpoint - `useEffect` dependency array includes reactive store value that gets updated by the effect itself | Removed reactive `profile` from dependency array. Use `usePhenotypeStore.getState().profile` inside effect to access current value without creating dependency. Effect runs once on mount with empty dependency array. | **Zustand Store in useEffect**: Never include reactive store values in `useEffect` dependency arrays if the effect updates those values. Use `store.getState()` to access current value inside effect without creating dependency. For one-time loads, use empty dependency array `[]`. If you need to react to store changes, use `useEffect` with store subscription or Zustand's built-in selector hooks. |
| **Type Adapter Pattern** | Prototype data structures don't match database types (SessionDetail vs SessionWithVotes) | Created `src/types/prototype.ts` with adapter functions (`sessionWithVotesToPrototype`, `workoutToPrototypeSession`) to transform between formats. Prototype types isolated from database schema. | **Data Transformation Layer**: When integrating prototype UI with real data, create explicit adapter functions. Keep prototype types separate from database types. Adapters handle all transformations (date formatting, enum mapping, metadata extraction). This allows prototype UI to remain unchanged while database schema evolves. |
| **Responsive Layout Pattern** | Mobile-first design requires different navigation (bottom nav vs sidebar) | Implemented conditional rendering in `layout.tsx` using Tailwind `md:` breakpoints. Mobile shows `TopNav` + `BottomNav`, desktop shows `Sidebar`. Main content uses `max-w-md mx-auto md:max-w-none` for mobile centering. | **Responsive Navigation**: Use conditional rendering based on screen size, not CSS-only hiding. Mobile-first means bottom navigation for thumb accessibility. Desktop uses sidebar for better screen real estate. Container width constraints (`max-w-md`) only apply on mobile to prevent text from stretching too wide. |
| **Probability Calculation Bug** | Macro-Engine probability showing 9580% (impossible value) | Removed double multiplication by 100, added 85% cap using `Math.min(85, probability)` in both Dashboard and ValuationEngine. Constant `MAX_PROBABILITY = 85` enforces "Zero-Error" philosophy - never promise certainty in chaotic biological systems. | **Probability Capping**: Always cap success probabilities at realistic maximums (85% for marathon). Never display >90% as it indicates over-fitting or ignoring Black Swan risks. Apply cap at both calculation and display layers. |
| **Decoupling Calculation Data Dependency** | Client-side EF calculation requires first/second half metrics that may not exist in metadata | Implemented fallback chain: (1) Use pre-calculated `decoupling` from metadata if available, (2) Calculate from `firstHalfPace/HR` and `secondHalfPace/HR` if available, (3) Fallback to estimated 2.5% if no data. | **Client-Side Calculation Fallbacks**: When implementing client-side calculations from metadata, always provide multiple fallback strategies. Document data dependencies clearly. Recommendation: Calculate and store first/second half metrics during session processing for accurate EF calculation. |
| **Integrity Ratio Unit Mismatch** | Ratio calculation (Tonnage/Volume) produces meaningless values (e.g., 10,000kg vs 100km = 100:1) | Normalize units before calculating ratio: `(Tonnage/1000) / (Volume/10)`. This prevents unit mismatch and makes ratio meaningful (e.g., 10kg tonnage / 10km volume = 0.1 ratio). | **Unit Normalization**: Always normalize units before calculating ratios between different measurement types. Document normalization factors clearly. Consider creating utility functions for common unit conversions (e.g., `normalizeTonnage()`, `normalizeVolume()`). |
| **Sync Button UX Failure** | Sync button disappears or becomes disabled after sync, requiring manual refresh | Button always visible with status indicators: "Syncing...", "Up to Date" (green), "Wait Xm" (cooldown), "Sync Garmin" (idle). Auto-sync check on app foreground (every 30s + on focus). Visual feedback shows last sync time in tooltip. | **Persistent Status Indicators**: Sync buttons should remain visible and show current status. Implement auto-sync checks on app foregrounding. Use visual indicators (colors, icons) to communicate state. Button is fallback, not primary interaction - status should be automatic. |
