# Architecture Decisions Log

| ID | Decision | Status | Context |
| :--- | :--- | :--- | :--- |
| ADR-001 | **Next.js (App Router) as Core Framework** | Accepted | We need a hybrid of static content (dashboards) and heavy client-side interactivity (Niggle Sliders, Agent Logic). Next.js offers the best PWA support and Server Actions for the "Monte Carlo" simulations. |
| ADR-002 | **Zustand for State Management** | Accepted | The "Micro-Agents" (Structural, Metabolic, Fueling) require complex, cross-component state access without prop drilling. Zustand is lightweight and handles transient updates (sliders) better than Context. |
| ADR-003 | **Supabase for Backend/Auth** | Accepted | We need rapid schema iteration for "Phenotype Configs" and "Session Logs". Supabase provides built-in Auth and a Postgres DB that fits our relational data needs (Users -> Sessions -> Votes). |
| ADR-004 | **Tailwind CSS for Styling** | Accepted | "Minimalist, Dark Mode default" vibe requires a utility-first approach for rapid UI development and consistent design tokens. |
| ADR-005 | **Client-Side Agent Logic (Modules M, E)** | Accepted | The "Daily Micro-Engine" (Agents A, B, C) must run instantly. We will implement these as pure TS functions running in the browser to enable immediate "Veto" feedback without network latency. |
| ADR-006 | **Server-Side Simulation (Module R)** | Accepted | The "Macro-Engine" (Monte Carlo Sim) is computationally expensive. This will run as a Server Action (Node.js) to offload the client and ensure consistent probabilistic modeling. |
| ADR-007 | **Hybrid Data Ingestion (Module K)** | Accepted | **Garmin MCP Webhooks** will be received by Supabase Edge Functions. **FIT File Parsing** will occur Server-Side (Node.js) to ensure robust "High-Rev Filtering" before data ever reaches the Client Agents. |
| ADR-008 | **Strict Module Separation** | Accepted | The codebase will strictly mirror the FRD structure: `src/modules/monitor`, `src/modules/kill`, `src/modules/execute`, `src/modules/review`. This ensures every FR has a dedicated home. |
| ADR-009 | **Phenotype "Truth" File Storage** | Accepted | The `Phenotype_Config` (FR-M1) will be stored in Supabase (Postgres) but cached locally (Zustand/LocalStorage) to allow offline "Chassis Checks" and immediate Agent initialization. |
| ADR-010 | **Python MCP for Raw FIT Parsing** | Accepted | To detect "Cadence Lock" (FR-K2), we need raw byte stream access which JS libraries struggle with. We implement a **Python FastMCP server** using `fitparse` to download and process `.FIT` files before passing clean JSON to the Next.js app. |
| ADR-011 | **Recharts for Data Visualization** | Accepted | For the web dashboard, we use **Recharts** (over Victory Native) as it integrates seamlessly with React/Next.js and allows highly customizable, responsive components like the "Chassis Integrity Gauge" and "Tonnage Candlestick". |
| ADR-012 | **MAKER Process Workflow** | Adopted | We enforce a strict **Decomposition -> Test (Red Flag) -> Implement -> Verify** loop. This "Measure Twice, Cut Once" approach prevents architectural drift and ensures every feature is verified against a strict failure condition before coding. |
| ADR-013 | **Atomic Module Decomposition** | Adopted | All store and orchestration files must be decomposed into `logic/` subdirectories when exceeding 100 lines. Each module follows single responsibility: `profileLoader.ts`, `profileUpdater.ts`, `persistence.ts`, etc. This ensures maintainability and testability. |
| ADR-014 | **Strict TypeScript Type Safety** | Enforced | Zero tolerance for `any` types. External APIs (e.g., Garmin) require proper TypeScript interfaces in `src/types/`. Error handling uses `unknown` with type guards. All function parameters must be explicitly typed. |
| ADR-015 | **Component Extraction Pattern** | Adopted | Large page components (>200 lines) are decomposed into smaller, reusable components in `components/` directory. Examples: `DashboardHeader`, `AlertBanner`, `AnalysisResultCard`, `AgentStatusGrid`. Each component handles a single UI concern. |
| ADR-016 | **History Page Data Joining Strategy** | Adopted | History page joins `session_logs` with `daily_monitoring` on date to display subjective inputs alongside session data. Agent votes loaded separately per session. Integrity flags extracted from session metadata. This approach maintains data normalization while providing rich audit log context. |
| ADR-017 | **Modal Interruption for Critical Decisions** | Adopted | Substitution modal uses full-screen overlay pattern to block user interaction until critical decision (niggle > 3) is acknowledged. Modal presents intervention options and triggers plan rewrite on selection. This ensures user cannot proceed without addressing structural risk. |
| ADR-018 | **Fragmented Garmin Sync with Date Range Chunking** | Adopted | Garmin sync uses manual-only approach with date-range selection. Date ranges >7 days are automatically split into sequential 7-day chunks processed one after another. Each chunk is a separate sync request with progress feedback ("1 of 5 patches processed"). This prevents rate limiting while allowing full historical imports. Chunking logic extracted to `logic/dateChunker.ts` for testability. |
| ADR-019 | **MCP Client for Garmin Sync with Token Persistence** | Adopted | Primary sync method uses MCP server's Python client via subprocess (`scripts/sync-garmin-mcp.py`). Provides OAuth token persistence (`~/.garminconnect/`), efficient `get_activities_by_date()` queries (single API call per chunk), and better error handling. Falls back to npm `garmin-connect` package if Python/MCP unavailable. This dramatically reduces rate limiting by avoiding repeated authentication and using date-range queries instead of pagination. |
| ADR-020 | **ValuationEngine as Separate Mathematical Logic Module** | Adopted | Mathematical calculations (Smart Adherence, Integrity Ratio, Blueprint Probability) isolated in `src/modules/analyze/valuationEngine.ts` as pure functions. No UI dependencies, can be tested independently. Follows single responsibility principle - calculation logic separate from display logic. This enables reuse across Dashboard, Lab, and future analytics views. |
| ADR-021 | **Client-Side Decoupling Calculation with Fallback Chain** | Adopted | Decoupling calculated client-side using Efficiency Factor (EF = Pace/HR) comparing first half vs second half. Implements fallback chain: (1) Pre-calculated from metadata, (2) Calculate from first/second half metrics, (3) Estimated fallback. This handles missing metadata gracefully while providing accurate calculations when data is available. Recommendation: Enhance session processor to calculate and store first/second half metrics during ingestion. |
| ADR-022 | **Unit Normalization for Ratio Calculations** | Adopted | Integrity Ratio calculation normalizes units before computing ratio: `(Tonnage/1000) / (Volume/10)`. This prevents meaningless ratios (e.g., 10,000kg vs 100km = 100:1) and makes ratio meaningful for comparison. All ratio calculations between different measurement types must normalize units first. |
| ADR-023 | **Probability Capping at Realistic Maximums** | Adopted | All success probabilities capped at 85% maximum (never promise certainty). Applied at both calculation layer (ValuationEngine) and display layer (Dashboard). Constant `MAX_PROBABILITY = 85` enforces "Zero-Error" philosophy - acknowledges 15% risk of structural failure in chaotic biological systems. Prevents over-fitting and false certainty. |
| ADR-024 | **Phase-Aware Volume Requirements** | Adopted | Volume requirements (Vol_Req) ramp by training phase: Phase 1 (60%), Phase 2 (80%), Phase 3 (100%), Phase 4 (50% taper). Phase 3 includes penalty if weekly volume < 50km (probability drops by 30%). This ensures probability calculations reflect realistic training phase expectations and penalize insufficient volume during peak performance phase. |
| ADR-025 | **Provisional Plan Display Pattern** | Adopted | Training plan shows 7 days (today + 6 future) with days 3-7 marked as "Provisional". Visual indicators: dashed border, reduced opacity, AlertCircle icon, tooltip "Subject to Daily Chassis Audit". This reinforces MAKER framework principle that Day 4 depends on Day 3's execution - plan is live, not static. Prevents false sense of certainty. |
| ADR-026 | **Persistent Sync Status with Auto-Check** | Adopted | Sync button always visible with status indicators ("Syncing...", "Up to Date", "Wait Xm", "Sync Garmin"). Auto-sync check on app foreground (every 30s + on focus). Visual feedback shows last sync time in tooltip. Button serves as fallback, not primary interaction - status is automatic. This improves UX by making sync status always visible without requiring manual refresh. |
| ADR-027 | **Tactical Map Calendar Date Range Alignment** | Adopted | Tactical Map calendar displays 7 days (3 past + today + 3 future). Database query must match this range exactly. Query loads sessions from 3 days ago to 3 days forward. Dates normalized to start of day (`setHours(0, 0, 0, 0)`) before querying/comparing. This ensures all displayed calendar days have corresponding data loaded. Calendar generation uses negative loop indices for past days: `for (let i = -3; i <= 3; i++)`. |
| ADR-028 | **Garmin Duration Extraction Null Safety** | Adopted | Python `extract_duration()` function uses explicit `is not None` checks before type validation. Priority order: check float number first (most common Garmin API format), then dict format (fallback). TypeScript side validates and skips activities with invalid durations (0 or < 1 minute) to prevent storing bad data. Comprehensive logging at each extraction step for debugging. This ensures robust duration extraction from Garmin API responses. |
| ADR-029 | **Dynamic Strength Training Metrics** | Adopted | "Hero Stats" section in SessionDetailView adapts dynamically based on session type. **Strength Sessions** display Volume (Reps) and Load (kg) instead of Distance/Pace. Protocol strings extracted from Garmin Exercise Sets API are parsed to calculate these totals. This ensures strength training is treated as a first-class citizen, not forced into a cardio-centric data model. |
| ADR-030 | **Force Re-Sync Strategy** | Adopted | Implemented a "Force Update" capability that bypasses persistence cache checks. The "Update" button in History triggers a deep sync with `reSync=true`, allowing retroactive enrichment of historical sessions with new metadata (e.g., protocols) without requiring manual data deletion. This enables safe iterative improvement of parsing logic. |
